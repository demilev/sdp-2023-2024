# Тема 3, Стек, 23.10.2023

## Стек

<br/>

![Diagram](content/stack.webp)

<br/>


Тип на структурата - **L**I**F**O (Last In, First Out)

## Задачи

### Зад. 1 - [Решение](solutions/stack/stack.h)

Създайте шаблонен клас `Stack`, който ще представя имплементация на структурата от данни стек. Преди да имплементирате голямата четворка, основните методи:

* `void push(const T&)` - слага елемент на върха на стека
* `void pop()` - премахва елемента от върха на стека
* `T top()` - връща елемента от върха на стека
* `int size()` - връща броя на елементите в стека
* `bool empty()` - проверява дали стекът е празен

### Зад. 2 - [Решение](solutions/stack/stack.h)

Имплементирайте голямата четворка за класа `Stack`.

### Зад. 3 (бонус) - [Решение](solutions/stack/stack_list.h)

Променете имплементацията на класа `Stack`, така че да се въпзолзва от вече съществуващата структура от данни свързан списък, която поддържа базовите операции на стека. За целта използвайте имплементацията на свързан списък от стандартната библиотека - [std::list](https://en.cppreference.com/w/cpp/container/list)

### Зад. 4 - [Решение](solutions/task04/)

Напишете функция, която приема стек и обръща съдържанието му(това, което е било на дъното, отива на върха на стека)

### Зад. 5 - [Решение](solutions/task05/)

Имплементирайте функция, която приема символен низ и която проверява дали е добре скобуван. Низ е добре скобуван, ако

1. за всяка затваряща скоба има отваряща от същия вид преди нея
2. за всяка затваряща скоба няма незатворена отваряща скоба от друг вид преди нея
3. за всяка отваряща скоба има затваряща от същия вид след нея

Пример:

* `(([{}()]))` е добре скобуван
* `(({})]` **не** е добре скобуван, защото нарушава първото правило
* `(({)})` **не** е добре скобуван, защото нарушава второто правило
* `(({}))[()` **не** е добре скобуван, защото нарушава третото правило

### Зад. 6 - [Решение](solutions/text-editor/)

Имплементирайте проста форма на текстов редактор, който позволява три операции:

* `void edit(std::function<std::string(std::string)> editFunction)` - която изпълнява `editFunction` върху текущото текстово съдържание и запазва резултата като новата версия на съдържанието
* `void print()` - отпечатва текущото съдържание
* `void undo()` - връща текста във формата му преди последната промяна
